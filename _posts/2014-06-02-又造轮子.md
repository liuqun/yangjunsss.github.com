---
layout: post
title: 又造轮子
categories: [ios]
tags: [NSArray, NSMutableArray,CFArray]
fullview: false
description: NSArray性能,CFArray
---

We are guessing Apple,but we don't know the Apple is guessing us!
喔～我们又造了一个轮子，我们用`NSMutableArray`造了一个类似的`CFStorage`的东东。上学的时候，老师会告诉学生Array的增删是耗时的，因为要数组复制，而访问是很快的，因为是直接寻址，时间复杂度是`O（1）`，基于这样一个印象，在大数据用Array的时候就会犹豫，比如100W条数据。

于是在oc上用`NSMutableArray`写了一个能满足增删要求又不至于使查询性能down下来的结构，后来测试`NSMutableArray`的增删查性能后发现，我们的确造了一个轮子。

自己的测试数据与以下类似：
![pimg](/assets/media/QQ20140602-6.png)

**结论是NSMutableArray的增删查性能都不错，详情见[这篇博客](http://ridiculousfish.com/blog/posts/array.html)**

进一步查了下[CFArray.c](http://www.opensource.apple.com/source/CF/CF-476.14/CFArray.c)会发现

{% highlight c++ %}
/* This shouldn't be called if the array count is 0. */
CF_INLINE struct __CFArrayBucket *__CFArrayGetBucketAtIndex(CFArrayRef array, CFIndex idx) {
    switch (__CFArrayGetType(array)) {
    case __kCFArrayImmutable:
    case __kCFArrayDeque:
	return __CFArrayGetBucketsPtr(array) + idx;
    case __kCFArrayStorage: {
	CFStorageRef store = (CFStorageRef)array->_store;
	return (struct __CFArrayBucket *)CFStorageGetValueAtIndex(store, idx, NULL);
    }
    }
    return NULL;
}
{% endhighlight %}

可见对于Immutable的读取的方法是`__CFArrayGetBucketsPtr`：
{% highlight c++ %}
/* Only applies to immutable and mutable-deque-using arrays;
 * Returns the bucket holding the left-most real value in the latter case. */
CF_INLINE struct __CFArrayBucket *__CFArrayGetBucketsPtr(CFArrayRef array) {
    switch (__CFArrayGetType(array)) {
    case __kCFArrayImmutable:
	return (struct __CFArrayBucket *)((uint8_t *)array + __CFArrayGetSizeOfType(((CFRuntimeBase *)array)->_cfinfo[CF_INFO_BITS]));
    case __kCFArrayDeque: {
	struct __CFArrayDeque *deque = (struct __CFArrayDeque *)array->_store;
        return (struct __CFArrayBucket *)((uint8_t *)deque + sizeof(struct __CFArrayDeque) + deque->_leftIdx * sizeof(struct __CFArrayBucket));
    }
    }
    return NULL;
}
{% endhighlight %}

可见是直接寻址，引申出另一个疑问：**为什么forin(fast enumerate)的查询速度最快？**

而mutable则用`CFStorageRef`来实现，在[CFArray.h](http://www.opensource.apple.com/source/CF/CF-550/CFArray.h)有一段作者的这样的说明：

_The access time for a value in the array is guaranteed to be at
	worst O(lg N) for any implementation, current and future, but will
	often be O(1) (constant time). Linear search operations similarly
	have a worst case complexity of O(N*lg N), though typically the
	bounds will be tighter, and so on. Insertion or deletion operations
	will typically be linear in the number of values in the array, but
	may be O(N*lg N) clearly in the worst case in some implementations.
	There are no favored positions within the array for performance;
	that is, it is not necessarily faster to access values with low
	indices, or to insert or delete values with high indices, or
	whatever._



### Javascrpit会怎样？

js在数据量达到一定级别的时候增删操作就会严重卡断，不同js引擎会不同，所以值得庆幸地是这个轮子并非全无价值；p

