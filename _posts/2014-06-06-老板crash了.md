---
layout: post
title: 老板，并发crash了！
categories: [ios]
tags: [ios]
fullview: false
keywords: CAS, NSMutableArray,GCD,NSlock
description: 

---

App在load的时候任务过重影响了性能，所以很自然的并发了，其中主线程对某个Array一直在append操作，而并发的code进行了get操作，结果就exc_bad_access了，有点不小心。Crash的测试code如下：
{% highlight objective-c %}
- (void) testOneAddAndMultiReadBug
{
    NSMutableArray *array = [NSMutableArray new];
    [array addObject:[VideoItem new]];
    for (NSInteger i=0; i<10000000; i++) {
        NSInteger count = [array count];
        VideoItem *e = array[count - 1]; // EXC_BAD_ACCESS!
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [array addObject:[VideoItem new]];
        });
    }
}
{% endhighlight %}

oc的Array和Map对并发的支持的确弱了点，线程安全都需要自己做- - ，但我还是怀疑了一会，因为这里只有一个线程做append，于是翻了下实现，CFArray简化的code如下：

{% highlight objective-c %}
struct __CFArrayImmutable {
    CFRuntimeBase _base;
    CFIndex _count;	/* number of objects */
};

void CFArrayAppendValue(CFMutableArrayRef array, const void *value) {
    _CFArrayReplaceValues(array, CFRangeMake(__CFArrayGetCount(array), 0), &value, 1);
}

void _CFArrayReplaceValues(CFMutableArrayRef array, CFRange range, const void **newValues, CFIndex newCount) {
    const void **newv, *buffer[256];
    cnt = __CFArrayGetCount(array);
    futureCnt = cnt - range.length + newCount;
    
    CFStorageRef store = ((struct __CFArrayMutable *)array)->_store;

    if (range.length < newCount) {
    CFStorageInsertValues(store, CFRangeMake(range.location + range.length, newCount - range.length));
	}
    
    if (0 < newCount) {
        if (__kCFArrayMutableStore == __CFArrayGetType(array)) {
            CFStorageRef store = ((struct __CFArrayMutable *)array)->_store;
            CFStorageReplaceValues(store, CFRangeMake(range.location, newCount), newv);
        }
    }
    
    __CFArraySetCount(array, futureCnt);
}
{% endhighlight %}

可以看到Append是先Insert然后再replace，这就有可能导致访问的内存不存在，crash了，于是只能做并发了。

**锁**和**非阻塞算法CAS**。

***先说锁***

1.全局锁，给整个Array加互斥锁，可以用NSLock或@synchronized来实现，实现简单但并发效率低。

2.读写锁，读线程之间不阻塞，只与写线程互斥，写线程之间相互互斥，这样来保证高效的并发读操作，而且比较简单，较符合我的需求。

3.局部锁，写过Java就肯定知道[ConcurrentHashMap](http://kickjava.com/src/java/util/concurrent/ConcurrentHashMap.java.htm)，DW上有几篇不错的分析[文章](http://www.ibm.com/developerworks/cn/java/j-jtp08223/)，是JDK1.5后对原来synchronized table，Map的高并发解决方案，大致的意思把Map数据分成多个Segment，每个Segment拥有锁，形成锁池，这样利用局部的锁来实现高并发的读写操作。
放个ConcurrentHashMap的put实现:

{% highlight java %}
public V put(K key, V value) {
    if (value == null)
        throw new NullPointerException  JavaDoc();
    int hash = hash(key);
    return segmentFor(hash).put(key, hash, value, false);
}
{% endhighlight %}

[Read more](http://kickjava.com/src/java/util/concurrent/ConcurrentHashMap.java.htm#ixzz33sZqQLUs)

***非阻塞算法Compare and Swap***

CAS比较厉害，CAS是利用硬件指令来检测内存值并进行替换来实现原子操作，从而避免了繁重的锁操作，参见[这里](http://www.ibm.com/developerworks/cn/java/j-jtp04186/) 简单来说就是先读取某内存的值为A，然后执行CAS操作，CAS会再次读取这个内存的值并判断是否还是A，如果是A，则进行SWAP，替换成新值B，如果这之中被其他线程改变了值变成了C，则重复再来一直到SWAP成功为止。代码如下：

{% highlight java %}
public final int getAndSet(int B) {
        for (;;) {
            int A = get();
            if (compareAndSet(A, B))
                return A;
        }
}
{% endhighlight %}

OC同样提供了这种原子操作，见[这里](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/ThreadSafety/ThreadSafety.html)。

CAS有个ABA的问题，就是需要读取的内存值一开始为A，然后被其他线程更改为B，然后再被更改回A，这时候CAS操作会认为指向的内存值并没有发生更改。怎么办？

最后，用多线程要非常小心，并也希望Apple在未来对高并发提供更好的支持；）

