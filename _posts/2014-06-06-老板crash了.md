---
layout: post
title: 老板，并发crash了！
categories: [ios]
tags: [ios]
fullview: false
keywords: CAS, NSMutableArray,GCD,NSlock
description: 

---

App在load的时候任务过重影响了性能，所以很自然想做并发，我的case是主线程对Array一直append操作，而并发的code进行了get操作，结果就exc_bad_access了，有点不小心。写的一个Crash的测试code如下：
{% highlight objective-c %}
- (void) testOneAddAndMultiReadBug
{
    NSMutableArray *array = [NSMutableArray new];
    [array addObject:[VideoItem new]];
    for (NSInteger i=0; i<10000000; i++) {
        NSInteger count = [array count];
        VideoItem *e = array[count - 1]; // EXC_BAD_ACCESS!
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [array addObject:[VideoItem new]];
        });
    }
}
{% endhighlight %}

oc的Array和Map对并发的支持的确弱了点，线程安全都需要自己保证- - ，但我还是怀疑了一会为什么会crash，因为这里只有一个线程做append，于是翻了下CFArray实现，简化code如下：

{% highlight objective-c %}
struct __CFArrayImmutable {
    CFRuntimeBase _base;
    CFIndex _count;	/* number of objects */
};

void CFArrayAppendValue(CFMutableArrayRef array, const void *value) {
    _CFArrayReplaceValues(array, CFRangeMake(__CFArrayGetCount(array), 0), &value, 1);
}

void _CFArrayReplaceValues(CFMutableArrayRef array, CFRange range, const void **newValues, CFIndex newCount) {
    const void **newv, *buffer[256];
    cnt = __CFArrayGetCount(array);
    futureCnt = cnt - range.length + newCount;
    
    CFStorageRef store = ((struct __CFArrayMutable *)array)->_store;

    if (range.length < newCount) {
    CFStorageInsertValues(store, CFRangeMake(range.location + range.length, newCount - range.length));
	}
    
    if (0 < newCount) {
        if (__kCFArrayMutableStore == __CFArrayGetType(array)) {
            CFStorageRef store = ((struct __CFArrayMutable *)array)->_store;
            CFStorageReplaceValues(store, CFRangeMake(range.location, newCount), newv);
        }
    }
    
    __CFArraySetCount(array, futureCnt);
}
{% endhighlight %}

可以看到append实际上是先insert然后再replace，这就有可能EBA了，于是做并发吧。

**锁**和**非阻塞算法CAS**。

***先说锁***

1.全局锁，最傻的办法，给整个Array加互斥锁，用NSLock或@synchronized来实现，实现简单但并发效率低，任何一个读写操作都阻塞其他线程。

2.读写锁，读线程之间不阻塞，只与写线程互斥，写线程之间相互互斥，这样来保证高效的并发读操作，而且比较简单，较符合我的需求。

3.局部锁，写过Java就肯定知道[ConcurrentHashMap](http://kickjava.com/src/java/util/concurrent/ConcurrentHashMap.java.htm)，DW上有几篇不错的[分析文章](http://www.ibm.com/developerworks/cn/java/j-jtp08223/)，是JDK1.5后对原来synchronized table，Map的高并发替代方案，大致的意思把Map数据分成多个Segment，每个Segment拥有锁，形成锁池，这样利用局部的锁来实现高并发的读写操作，MM有篇大作。
放个ConcurrentHashMap的put来事例下:

{% highlight java %}
public V put(K key, V value) {
    if (value == null)
        throw new NullPointerException  JavaDoc();
    int hash = hash(key);
    return segmentFor(hash).put(key, hash, value, false);
}
{% endhighlight %}

看到segmentFor(hash)应该就懂了；）[Read more](http://kickjava.com/src/java/util/concurrent/ConcurrentHashMap.java.htm#ixzz33sZqQLUs)

***非阻塞算法Compare and Swap***

CAS比较有意思（最傻最高效的办法），CAS是利用硬件指令轮训来检测内存值是否进行了变化，并进行赋值的原子操作，从而避免了使用锁，思想参见[这里](http://www.ibm.com/developerworks/cn/java/j-jtp04186/) 举个例子：先读取某内存的值为A，然后执行CAS操作，CAS会再次读取这个内存的值并判断是否还是A，如果是A，则进行SWAP，替换成新值B，如果这之中被其他线程改变了值变成了C，则不赋值，重复再轮询，一直到SWAP成功为止。伪代码如下：

{% highlight java %}
public final int getAndSet(int B) {
        for (;;) {
            int A = get();
            if (compareAndSet(A, B))
                return A;
        }
}
{% endhighlight %}

OC提供的原子操作，见[这里](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/ThreadSafety/ThreadSafety.html)。

细心的你会发现，CAS有个ABA的BUG，就是假如内存值一开始为A，然后被其他线程更改为B，然后再被更改回A，这时候CAS操作会认为指向的内存值并没有发生改变了- -！

最后，用多线程要非常小心，Apple似乎也没太注重这个问题，只能别让自己掉进坑里，掉进了也只能自救；)

