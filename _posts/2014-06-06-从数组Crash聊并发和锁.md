---
layout: post
title: 从数组Crash聊并发和锁
categories: [iOS]
tags: [iOS]
fullview: false
keywords: CAS, NSMutableArray,GCD,NSlock
description: App在load的时候任务过重影响了性能，所以很自然想做并发，我的case是主线程对Array一直append操作，而并发的code进行了read操作，crash了

---

App在load的时候任务过重影响了性能，所以很自然想做并发，我的case是主线程对Array一直append操作，而并发的code进行了read操作，应该不会crash，但为什么就exc_bad_access了呢？于是写了一个测试code，运行正常：

```
- (void) testOneAddAndMultiReadBug
{
    NSMutableArray *array = [NSMutableArray new];
    for (NSInteger i=0; i<100000; i++) {
        [array addObject:[VideoItem new]];
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSInteger count = [array count];
            VideoItem *e = array[count - 1];
        });
        [array addObject:[VideoItem new]];
    }
}
```


于是看了下CFArray的Append实现，简化code如下：

{% highlight objective-c %}
struct __CFArrayImmutable {
    CFRuntimeBase _base;
    CFIndex _count;	/* number of objects */
};

void CFArrayAppendValue(CFMutableArrayRef array, const void *value) {
    _CFArrayReplaceValues(array, CFRangeMake(__CFArrayGetCount(array), 0), &value, 1);
}

void _CFArrayReplaceValues(CFMutableArrayRef array, CFRange range, const void **newValues, CFIndex newCount) {
    const void **newv, *buffer[256];
    cnt = __CFArrayGetCount(array);
    futureCnt = cnt - range.length + newCount;
    
    CFStorageRef store = ((struct __CFArrayMutable *)array)->_store;

    if (range.length < newCount) {
    CFStorageInsertValues(store, CFRangeMake(range.location + range.length, newCount - range.length));
	}
    
    if (0 < newCount) {
        if (__kCFArrayMutableStore == __CFArrayGetType(array)) {
            CFStorageRef store = ((struct __CFArrayMutable *)array)->_store;
            CFStorageReplaceValues(store, CFRangeMake(range.location, newCount), newv);
        }
    }
    
    __CFArraySetCount(array, futureCnt);
}
{% endhighlight %}

虽然append是先insert然后再replace，但setcount操作总在最后，应该没问题，但后来发现写成了下面这样:

{% highlight objective-c %}
- (void) testOneAddAndMultiReadBug
{
    NSMutableArray *array = [NSMutableArray new];
    for (NSInteger i=0; i<100000; i++) {
        [array addObject:[VideoItem new]];
        array[[array count] - 1] = [VideoItem new];
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSInteger count = [array count];
            VideoItem *e = array[count - 1]; //EXC_BAD_ADDRESS
        });
        [array addObject:[VideoItem new]];
    }
}
{% endhighlight %}

先append，然后replace了count - 1位置的元素导致read到野指针就crash了，解决的办法很简单，不要做replace就好了，如果非要replace操作，则可以用**锁**和**非阻塞算法CAS**。

***锁***

1.全局锁，最傻的办法，给整个Array加互斥锁，用NSLock或@synchronized来实现，实现简单但并发效率低，任何一个读写操作都阻塞其他线程。

2.读写锁，读线程之间不阻塞，只与写线程互斥，写线程之间相互互斥，这样来保证高效的并发读操作，以上的问题code可以改成：

{% highlight objective-c %}
- (void) testOneAddAndMultiReadBugFix
{
    NSMutableArray *array = [NSMutableArray new];
    __block pthread_rwlock_t rwlock;
    if (pthread_rwlock_init(&rwlock, NULL)!=0) {
        return; // error
    }
    for (NSInteger i=0; i<100000; i++) {
        pthread_rwlock_wrlock(&rwlock);
        [array addObject:[VideoItem new]];
        array[[array count] - 1] = [VideoItem new];
        pthread_rwlock_unlock(&rwlock);
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            pthread_rwlock_rdlock(&rwlock);
            NSInteger count = [array count];
            VideoItem *e = array[count - 1];
            pthread_rwlock_unlock(&rwlock);
        });
    }
    pthread_rwlock_destroy(&rwlock);
}
{% endhighlight %}

3.局部锁，写过Java就肯定知道[ConcurrentHashMap](http://kickjava.com/src/java/util/concurrent/ConcurrentHashMap.java.htm)，DW上有几篇不错的[分析文章](http://www.ibm.com/developerworks/cn/java/j-jtp08223/)，是JDK1.5后对原来synchronized table，Map的高并发替代方案，大致的意思把Map数据分成多个Segment，每个Segment拥有锁，形成锁池，这样利用局部的锁来实现高并发的读写操作，MM有篇大作。
放个ConcurrentHashMap的put来事例下:

{% highlight java %}
public V put(K key, V value) {
    if (value == null)
        throw new NullPointerException  JavaDoc();
    int hash = hash(key);
    return segmentFor(hash).put(key, hash, value, false);
}
{% endhighlight %}

看到segmentFor(hash)应该就懂了；）[Read more](http://kickjava.com/src/java/util/concurrent/ConcurrentHashMap.java.htm#ixzz33sZqQLUs)

***非阻塞算法Compare and Swap***

CAS比较有意思（最傻最高效的办法），CAS是利用硬件指令轮训来检测内存值是否进行了变化，并进行赋值的原子操作，从而避免了使用锁，思想参见[这里](http://www.ibm.com/developerworks/cn/java/j-jtp04186/) 举个例子：先读取某内存的值为A，然后执行CAS操作，CAS会再次读取这个内存的值并判断是否还是A，如果是A，则进行SWAP，替换成新值B，如果这之中被其他线程改变了值变成了C，则不赋值，重复再轮询，一直到SWAP成功为止。伪代码如下：

{% highlight java %}
public final int getAndSet(int B) {
        for (;;) {
            int A = get();
            if (compareAndSet(A, B))
                return A;
        }
}
{% endhighlight %}

OC提供的原子操作，见[这里](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/ThreadSafety/ThreadSafety.html)。

细心的你会发现，CAS有个ABA的BUG，就是假如内存值一开始为A，然后被其他线程更改为B，然后再被更改回A，这时候CAS操作会认为指向的内存值并没有发生改变了- -！

最后，用多线程要非常小心，Apple似乎也没太注重这个问题，只能别让自己掉进坑里，掉进了也只能自救；)

##### Copyright © 2016 yangjunsss. All rights reserved.