---
layout: post
title: oc选择做清洁工？不支持多继承和重载
categories: [ios]
tags: []
fullview: false
keywords: Method, isa,MetaClass,runtime
description:

---

OC是不支持多继承和重载函数的，这个问题应该被很多人问过为什么？先看看oc的类体系结构吧

类定义：

typedef struct objc_class *Class; // 指向objc_class结构体指针

objc_class定义：

struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY; // 类的isa指针指向metaClass

#if !__OBJC2__
    Class super_class; // 当前类的父类
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list **methodLists; // 方法列表
    struct objc_cache *cache; // 在查询类方法时用的缓存
    struct objc_protocol_list *protocols; // 协议列表
#endif

} OBJC2_UNAVAILABLE;

类对象id定义：

typedef struct objc_object *id; // 指向objc_object结构体指针

objc_object定义:

struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};



类方法定义：

struct objc_method {
    SEL method_name; // 方法名
    char *method_types; // 方法类型
    IMP method_imp; // 函数指针
}

SEL的定义:

typedef struct objc_selector *SEL;

objc_selector:



IMP函数指针的定义:

typedef id (*IMP)(id, SEL, ...);



objc_method结构体定义了Class的某个方法，被存储在objc_method_list里，list长这样：

struct objc_method_list {
    struct objc_method_list *obsolete;
    int method_count;
    /* variable length structure */
    struct objc_method method_list[1];
}

到此为止，关于Method的结构就差不多了，然后它被Class所用：



