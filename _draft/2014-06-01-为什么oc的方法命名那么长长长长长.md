---
layout: post
title: 不支持多继承和重载
categories: [ios]
tags: []
fullview: false
keywords: Method, isa,MetaClass,runtime
description:

---

OC是不支持多继承和重载函数的，这个问题应该被很多人问过为什么？先看看oc的类体系结构吧

类定义：

typedef struct objc_class *Class; // 指向objc_class结构体指针

objc_class定义：

struct objc_class {
    // 类的isa指针指向metaClass
    Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
    Class super_class; // 父类
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list **methodLists; // 方法列表
    struct objc_cache *cache; // 在查询类方法时用的缓存
    struct objc_protocol_list *protocols; // 协议列表
#endif

} OBJC2_UNAVAILABLE;

类对象id定义：

typedef struct objc_object *id; // 指向objc_object结构体指针

objc_object定义:

struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

Class中引用methodLists，定义如下：

struct objc_method_list {
    struct objc_method_list *obsolete;
    int method_count;
    /* variable length structure */
    struct objc_method method_list[1];
}

主要是引用objc_method：

struct objc_method {
    // 方法名
    // typedef struct objc_selector *SEL;(- -木有找到selector结构体的定义,help)
    SEL method_name;
    char *method_types; // 方法类型
    // 函数指针
    // typedef id (*IMP)(id, SEL, ...);
    IMP method_imp;
}

那oc是如何添加method的呢？

/***********************************************************************
* class_addMethods.
*
* Formerly class_addInstanceMethods ()
**********************************************************************/
void	class_addMethods       (Class				cls,
                             struct objc_method_list *	meths)
{
    // Insert atomically.
    _objc_insertMethods (meths, &((struct objc_class *) cls)->methodLists);

    // Must flush when dynamically adding methods.  No need to flush
    // all the class method caches.  If cls is a meta class, though,
    // this will still flush it and any of its sub-meta classes.
    flush_caches (cls, NO);
}

/***********************************************************************
* class_removeMethods.
**********************************************************************/
void	class_removeMethods    (Class				cls,
                             struct objc_method_list *	meths)
{
    // Remove atomically.
    _objc_removeMethods (meths, &((struct objc_class *) cls)->methodLists);

    // Must flush when dynamically removing methods.  No need to flush
    // all the class method caches.  If cls is a meta class, though,
    // this will still flush it and any of its sub-meta classes.
    flush_caches (cls, NO);
}

最后只能追溯到objc-private的申明- -

// in objc-private.h

    OBJC_EXPORT BOOL class_respondsToMethod(Class, SEL);
    OBJC_EXPORT IMP class_lookupMethod(Class, SEL);
    OBJC_EXPORT IMP class_lookupMethodInMethodList(struct objc_method_list *mlist, SEL sel);
    OBJC_EXPORT IMP class_lookupNamedMethodInMethodList(struct objc_method_list *mlist, const char *meth_name);
    OBJC_EXPORT void _objc_insertMethods( struct objc_method_list *mlist, struct objc_method_list ***list );
    OBJC_EXPORT void _objc_removeMethods( struct objc_method_list *mlist, struct objc_method_list ***list );


/***********************************************************************
* class_getInstanceMethod.  Return the instance method for the
* specified class and selector.
**********************************************************************/
Method		class_getInstanceMethod	       (Class		aClass,
                                        SEL		aSelector)
{
    // Need both a class and a selector
    if (!aClass || !aSelector)
        return NULL;

    // Go to the class
    return _getMethod (aClass, aSelector);
}

/***********************************************************************
* class_getClassMethod.  Return the class method for the specified
* class and selector.
**********************************************************************/
Method		class_getClassMethod	       (Class		aClass,
                                     SEL		aSelector)
{
    // Need both a class and a selector
    if (!aClass || !aSelector)
        return NULL;

    // Go to the class or isa
    return _getMethod (GETMETA(aClass), aSelector);
}

static inline Method _getMethod(Class cls, SEL sel) {
    for (; cls; cls = cls->super_class) {
        Method m = _findMethodInClass(cls, sel);
        if (m) return m;
    }
    return NULL;
}

static inline Method _findMethodInClass(Class cls, SEL sel) {
    struct objc_method_list *mlist;
    void *iterator = 0;
    while ((mlist = _class_inlinedNextMethodList(cls, &iterator))) {
        Method m = _findMethodInList(mlist, sel);
        if (m) return m;
    }
    return NULL;
}

/* These next three functions are the heart of ObjC method lookup. */
static inline Method _findMethodInList(struct objc_method_list * mlist, SEL sel) {
    int i;
    if (!mlist) return NULL;
    for (i = 0; i < mlist->method_count; i++) {
        Method m = &mlist->method_list[i];
        if (m->method_name == sel) {
            return m;
        }
    }
    return NULL;
}






Class中引用objc_ivar_list来存储成员变量:

成员变量定义:

struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;

struct objc_ivar_list {
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}   


void object_setIvar(id obj, Ivar ivar, id value)
{
    if (obj  &&  ivar) {
        objc_assign_ivar_internal(value, obj, ivar_getOffset(ivar));
    }
}

Ivar object_setInstanceVariable(id obj, const char *name, void *value)
{
    Ivar ivar = NULL;

    if (obj && name) {
        if ((ivar = class_getInstanceVariable(obj->isa, name))) {
            objc_assign_ivar_internal(
                             (id)value, 
                             obj, 
                             ivar_getOffset(ivar));
        }
    }
    return ivar;
}

/***********************************************************************
* class_getInstanceVariable.  Return the named instance variable.
*
* Someday add class_getClassVariable ().
**********************************************************************/
Ivar	class_getInstanceVariable	       (Class		aClass,
                                       const char *	name)
{
    // Must have a class and a name
    if (!aClass || !name)
        return NULL;

    // Look it up
    return class_getVariable (aClass, name);
}

那句`Someday add class_getClassVariable ()`比较interesting

/***********************************************************************
* class_getVariable.  Return the named instance variable.
**********************************************************************/
static Ivar	class_getVariable	       (Class		cls,
                                      const char *	name)
{
    struct objc_class *	thisCls;

    // Outer loop - search the class and its superclasses
    for (thisCls = cls; thisCls != Nil; thisCls = ((struct objc_class *) thisCls)->super_class)
    {
        int	index;
        Ivar	thisIvar;

        // Skip class having no ivars
        if (!thisCls->ivars)
            continue;

        // Inner loop - search the given class
        thisIvar = &thisCls->ivars->ivar_list[0];
        for (index = 0; index < thisCls->ivars->ivar_count; index += 1)
        {
            // Check this ivar's name.  Be careful because the
            // compiler generates ivar entries with NULL ivar_name
            // (e.g. for anonymous bit fields).
            if ((thisIvar->ivar_name) &&
                (strcmp (name, thisIvar->ivar_name) == 0))
                return thisIvar;

            // Move to next ivar
            thisIvar += 1;
        }
    }

    // Not found
    return NULL;
}



struct objc_protocol_list {
    struct objc_protocol_list *next;
    long count;
    Protocol *list[1];
};


/***********************************************************************
* _internal_class_createInstanceFromZone.  Allocate an instance of the
* specified class with the specified number of bytes for indexed
* variables, in the specified zone.  The isa field is set to the
* class, all other fields are zeroed.
**********************************************************************/
static id	_internal_class_createInstanceFromZone (Class		aClass,
                                                  unsigned	nIvarBytes,
                                                  void *	z)
{
    id			obj;
    register unsigned	byteCount;

    // Can't create something for nothing
    if (aClass == Nil)
    {
        __objc_error ((id) aClass, _errAllocNil, 0);
        return nil;
    }

    // Allocate and initialize
    byteCount = ((struct objc_class *) aClass)->instance_size + nIvarBytes;
    obj = (id) malloc_zone_calloc (z, 1, byteCount);
    if (!obj)
    {
        __objc_error ((id) aClass, _errNoMem, ((struct objc_class *) aClass)->name, nIvarBytes);
        return nil;
    }

    // Set the isa pointer
    obj->isa = aClass;
    return obj;
}






uintptr_t
_objc_rootRetainCount(id obj)
{
    assert(obj);
    assert(!UseGC);

    // XXX -- There is no way that anybody can use this API race free in a
    // threaded environment because the result is immediately stale by the
    // time the caller receives it.

    if (OBJC_IS_TAGGED_PTR(obj)) return (uintptr_t)obj;    

    SideTable *table = SideTable::tableForPointer(obj);

    size_t refcnt_result = 1;
    
    OSSpinLockLock(&table->slock);
    RefcountMap::iterator it = table->refcnts.find(DISGUISE(obj));
    if (it != table->refcnts.end()) {
        refcnt_result = (it->second >> 1) + 1;
    }
    OSSpinLockUnlock(&table->slock);
    return refcnt_result;
}


typedef objc::DenseMap<id,size_t,true> RefcountMap;

class SideTable {
private:
    static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];

public:
    OSSpinLock slock;
    RefcountMap refcnts;
    weak_table_t weak_table;

    SideTable() : slock(OS_SPINLOCK_INIT)
    {
        memset(&weak_table, 0, sizeof(weak_table));
    }
    
    ~SideTable() 
    {
        // never delete side_table in case other threads retain during exit
        assert(0);
    }

    static SideTable *tableForPointer(const void *p) 
    {
#     if SIDE_TABLE_STRIPE == 1
        return (SideTable *)table_buf;
#     else
        uintptr_t a = (uintptr_t)p;
        int index = ((a >> 4) ^ (a >> 9)) & (SIDE_TABLE_STRIPE - 1);
        return (SideTable *)&table_buf[index * SIDE_TABLE_SIZE];
#     endif
    }

    static void init() {
        // use placement new instead of static ctor to avoid dtor at exit
        for (int i = 0; i < SIDE_TABLE_STRIPE; i++) {
            new (&table_buf[i * SIDE_TABLE_SIZE]) SideTable;
        }
    }
    
    static bool noLocksHeld(void) {
        bool gotAll = true;
        for (int i = 0; i < SIDE_TABLE_STRIPE && gotAll; i++) {
            SideTable *s = (SideTable *)(&table_buf[i * SIDE_TABLE_SIZE]);
            if (OSSpinLockTry(&s->slock)) {
                OSSpinLockUnlock(&s->slock);
            } else {
                gotAll = false;
            }
        }
        return gotAll;
    }
};

DenseMap.h
http://llvm.org/docs/doxygen/html/DenseMap_8h_source.html
