---
description: "
"
---

#### 摘要
  Docker 是一种面向开发和运维人员进行开发、部署和运行的整体容器平台，使用 Linux Namespace（UTS、IPC、PID、Network、Mount、User）和 cgroups（Control Groups）技术对容器进行虚拟化隔离和资源管控，并拥有灵活性、轻量、可扩展性、可伸缩性等特点。容器是一种进程级别虚拟化技术，所有容器实例进程公用同一个 Kernel 内核。启动一个 Docker 容器实例是从镜像文件加载，镜像文件包含应用所需所有的可执行文件、配置文件、运行时、依赖库、环境变量。镜像文件主要包括 Blob 目录和 Manifest 目录，Blobs 存储实际的数据文件，Manifest 存储文件元数据。Docker 提供一种集中式、无状态、高扩展性的管理镜像文件的 Docker Registry 仓库服务，Docker Registry 仓库服务提供镜像的管理、存储、用户鉴权、WebHook 通知、日志、代理等功能。根据镜像存储的分层和无状态的特点，这篇文章描述了另一种存储和管理镜像文件的镜像仓库服务，它采用全分布式 P2P 架构，没有中心管理节点，每一个节点既是服务的使用者又是服务的提供者，这种方法提供了更高效的并发量和可靠性。

#### 继承和分层模型
  为了最大地节省存储空间、高效复用和制作快捷，镜像文件采用分层继承的思想来组织，即镜像之间可以相互继承，被继承的镜像叫做 Parent 父镜像，最初的镜像叫做 Base 基础镜像，所有的镜像往上回溯最终都能到达 Base 基础镜像。不仅仅镜像间相互依赖，镜像内部的分层结构也相互依赖，镜像内部文件组织形式分为多个层级，每一个层级单独存储着一定的文件，层级间从下到上依次继承，当新的文件写入、更新、删除时，则生成最上层的新的层级，旧的层级为 readonly 可读属性，当前新的层级为 writeable 可写属性，最终用户看到的是由多个层级 Merge 合并后的文件内容。

  一个典型的镜像依赖如下：

  ![img](/images)

   alpine 是基础镜像，提供了一个轻量的、安全的 Linux 运行环境，Basic App1 和 Basic App2 都基于和共享这个基础镜像 alpine，Basci App 1/2 可作为一个单独的镜像发布，同时也是 Advanced App 2/3 的父镜像，在 Advanced App 2/3 下载的时候，会检测并下载所有的父镜像和基础镜像，而往往在 registry 存储节点里，只会有一个父镜像实例和基础镜像实例，从而高效节省存储空间。

   一个典型的镜像内分层结构如下：

   ![img](/images)

   在镜像内部也采用分层的结构存储，Advanced App1 内部文件分为 5 个 layer 层存储，每一层在 registry 中都为 application/vnd.docker.image.rootfs.diff.tar.gzip 压缩类型文件，每一层存储自己的文件内容，每一个 layer 都计算一个 sha256 的值进行标示，所有 layer 层的文件组成了最终镜像的内容，在容器从镜像启动后，所有 layer 层的文件内容 merge 合并称一个整体的文件结构。

```sh
$ file /var/lib/registry/docker/registry/v2/blobs/sha256/40/4001a1209541c37465e524db0b9bb20744ceb319e8303ebec3259fc8317e2dec/data
data: gzip compressed data
$ sha256sum /var/lib/registry/docker/registry/v2/blobs/sha256/40/4001a1209541c37465e524db0b9bb20744ceb319e8303ebec3259fc8317e2dec/data
4001a1209541c37465e524db0b9bb20744ceb319e8303ebec3259fc8317e2dec
```
   其中一种实现分层模型的文件系统为 UnionFS 联合文件系统，UnionFS 的实现主要有 AUFS、Overlay、Overlay2 文件系统，UnionFS 的允许文件和文件夹的分成多个 Branch(Layer) 管理，并最终 mount 挂载的虚拟文件系统为所有 Branches 集合和合并而成，并当在 Write 写操作时，采用 copy-on-write 从原 Branch 中的文件 copy 拷贝一份到新 Branch 层，再进行写操作，当多个 Branch 层拥有同一个文件名的文件时，则优先使用最上层的 Branch 文件。

   使用 AUFS 构建一个 2 层 Layer 如下：

   ```sh
   $ mkdir /tmp/rw /tmp/r /tmp/aufs
   $ mount -t aufs -o br=/tmp/rw:/tmp/r none /tmp/aufs
   ````
   创建了2个层级目录分别是 /tmp/rw 和 /tmp/r，同时 br= 指定了所有的 branch 层，默认情况下 br=/tmp/rw 为可写层，: 后面只读层。

```sh
$ ls -l /tmp/rw/
-rw-r--r-- 1 root       root       23 Mar 25 14:21 file_in_rw_dir

$ ls -l /tmp/r/
-rw-r--r-- 1 root       root            26 Mar 25 14:20 file_in_r_dir

$ ls -l /tmp/aufs/
-rw-r--r-- 1 root       root            26 Mar 25 14:20 file_in_r_dir
-rw-r--r-- 1 root       root            23 Mar 25 14:21 file_in_rw_dir
```
最终挂载的虚拟文件目录在 /tmp/aufs，内容为 /tmp/rw 和 /tmp/r 目录下的集合和合并，UnionFS 每一个 branch 对应着镜像文件中的每一个 Layer，当有新的文件写操作的时候则写入 /tmp/rw 这个拥有写权限的 Branch 中，在 registry 中，每一个 Layer 都打包成一个 gzip 压缩文件，并以压缩文件的 sha256 命名，一个 layer 文件只存一份。

#### 寻找某个 Layer 数据

#### 发布新的 Layer 数据

#### 删除 Layer 数据

#### Peer 节点加入网络的认证
1. Peer 不持有证书，token 经过认证服务器认证鉴权
2. Peer 持有 RSA 公钥

#### P2P 介绍
简单描述下 P2P 有哪些协议，每种协议如何工作

##### BT

##### XXX

#### 去中心化 Docker 镜像仓库

##### 本地镜像仓库
描述下本地镜像仓库文件存储的结构

##### 组网结构
描述 Peer 如何组网，并且如何查找某个 Peer 节点的

##### 消息传递

###### 我存储了什么
描述如何寻找一个合适的节点存储

###### 我倾向存储什么
描述如果在网络中查找某个 layer



##### 激励机制

##### 验证宿主工作有效性
