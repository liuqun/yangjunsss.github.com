---
description: "
之前一篇博文分析了容器网络 Flannel 的 backend 的基本原理和验证，在容器网络方案中，Calico 的方案也是主流常用的方案，这篇文章对 Calico 进行基本原理分析和模拟验证。
"
---
### 摘要

之前一篇博文分析了容器网络 Flannel 的 backend 的基本原理和验证，在容器网络方案中，Calico 的方案也是主流常用的方案，这篇文章对 Calico 进行基本原理分析和模拟验证。

### 简介

官方定义如下：

```text
Calico provides secure network connectivity for containers and virtual machine workloads.

Calico creates and manages a flat layer 3 network, assigning each workload a fully routable IP address. Workloads can communicate without IP encapsulation or network address translation for bare metal performance, easier troubleshooting, and better interoperability. In environments that require an overlay, Calico uses IP-in-IP tunneling or can work with other overlay networking such as flannel.

Calico also provides dynamic enforcement of network security rules. Using Calico’s simple policy language, you can achieve fine-grained control over communications between containers, virtual machine workloads, and bare metal host endpoints.
```

Calico 为容器和 vm 提供一个网络安全的解决方案，Calico 构建一个扁平的三层网络方案，即所有的 guest 之间全部走路由表，并不关心 ARP 表，并不使用 IP 封装或 NAT 技术，节点间的路由信息使用 BGP 协议来实现，这样获取更好的网络性能、易维护且可交互性。在一些特定场景中可使用 IP-IP 隧道技术或者与 Flannel 配合构建网络。另外 Calico 提供一种动态安全策略，使用简易的策略语言来控制容器、虚拟机、物理之间的网络安全。

可见，Calico 的网络不使用 Overlay 技术的实现，而完全通过动态路由和 ACL 安全策略实现，并且也能与 flannel 的网路方案集成，说是一个网络安全方案更准确。

### 架构

Calico 由 5 部分组件组成：
1. Felix，运行在每一台 Host 的 agent 进程，主要负责网络接口管理和监听、路由、ARP 管理、ACL 管理和同步、状态上报等
2. Orchestrator Plugin，编排插件，并不是独立运行的某些进程，而是设计与 k8s、OpenStack等平台集成的插件，如 Neutron’s ML2 plugin 用于用户使用 Neutron API 来管理 Calico，本质是要解决模型和 API 间的兼容性问题。
3. Etcd，Calico 模型的存储引擎，这个没什么解释的，本质是一个 KV 数据库。
4. BGP Client（BIRD），Calico 为每一台 Host 部署一个 BGP Client，使用 BIRD 项目实现，BIRD 是一个单独的持续发展的项目，实现了众多动态路由协议比如 BGP、OSPF、RIP 等。在 Calico 的角色是监听 Host 上由 Felix 注入的路由信息，然后通过 BGP 协议广播告诉其他与它互联的 Host 节点，某个 IP 在我这，下一跳指向我，从而实现网络互通。
5. BGP Route Reflector(BIRD)，在大型网络规模中，如果仅仅使用 BGP client 形成 mesh 全网互联的方案就会导致规模限制，因为所有节点之间需要俩俩互联，通常需要 N^2 个连接，为了解决这个问题，可以采用 BGP 常用的 RR 的方法，简单说所有 BGP Client 仅与特定 RR 节点互联并做路由同步。

因此，整体可以画出构架如下：

![img](http://yangjunsss.github.io/images/calico/calico_arch.png)

### 模拟组网

组网如下：

![img](http://yangjunsss.github.io/images/calico/calico_network.png)

路由配置如下：

```sh
# HOST0
[root@i-7dlclo08 ~]# ip r
default via 192.168.100.1 dev eth0  proto static  metric 100
10.20.1.2 dev veth0  scope link
10.20.2.0/24 via 192.168.100.3 dev eth0
192.168.100.0/24 dev eth0  proto kernel  scope link  src 192.168.100.2  metric 100
[root@i-7dlclo08 ~]# ip netns exec ns0 ip r
default via 169.254.1.1 dev eth0
169.254.1.1 dev eth0  scope link
[root@i-7dlclo08 ~]# ip netns exec ns0 ip n
192.168.100.2 dev eth0 lladdr 0a:1a:e0:05:f9:60 STALE
169.254.1.1 dev eth0 lladdr 0a:1a:e0:05:f9:60 PERMANENT
[root@i-7dlclo08 ~]# ip -d a
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 52:54:ca:9d:db:ff brd ff:ff:ff:ff:ff:ff promiscuity 0
    inet 192.168.100.2/24 brd 192.168.100.255 scope global dynamic eth0
       valid_lft 40107sec preferred_lft 40107sec
    inet6 fe80::76ef:824d:95ef:18a3/64 scope link
       valid_lft forever preferred_lft forever
6: veth0@if5: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 0a:1a:e0:05:f9:60 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0
    veth
    inet6 fe80::81a:e0ff:fe05:f960/64 scope link
       valid_lft forever preferred_lft forever

```

网络连通性测试：

```sh
# HOST0
[root@i-7dlclo08 ~]# ip netns exec ns0 ping 10.20.2.2
PING 10.20.2.2 (10.20.2.2) 56(84) bytes of data.
64 bytes from 10.20.2.2: icmp_seq=1 ttl=62 time=0.774 ms
64 bytes from 10.20.2.2: icmp_seq=2 ttl=62 time=0.332 ms
[root@i-7dlclo08 ~]# ip netns exec ns0 ping 192.168.100.3
PING 192.168.100.3 (192.168.100.3) 56(84) bytes of data.
64 bytes from 192.168.100.3: icmp_seq=1 ttl=63 time=1.00 ms
64 bytes from 192.168.100.3: icmp_seq=2 ttl=63 time=0.695 ms
```

关键点：
1. 所有 guest 内的路由都一样，默认路由走 169.254.1.1 这个地址，并且 169.254.1.1 地址的 MAC 地址为 host 中的 veth0 的地址(所有 veth0 的 MAC 地址可以配置成一样)，目的是为了让数据包能正确送达到 host 的 namespace 中。
2. 整个方案不关心 guest 的 MAC 地址，不做 ARP 二层寻址，这也是为什么说 Calico 是一个纯三层的方案，host 中的数据包不管是同一个子网还是不同子网，都从三层 FID 表中进行路由。
3. 在以上方案基础上做 ACL 安全配置实现 Overlay 和 Underlay 的隔离及租户间的隔离。

### 总结
